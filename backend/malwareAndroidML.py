import pandas as pd
from flask import Flask, request, jsonify
import os
import re
from androguard.core.bytecodes.apk import APK
from androguard.core.bytecodes.dvm import DalvikVMFormat
from concurrent.futures import ThreadPoolExecutor
import aiofiles
from joblib import load

# Load pre-trained model
voting_clf = load('malware_detector.joblib')
data = pd.read_csv('malwarebenignfeatures.csv')
feature_df = pd.read_csv('dataset-features-categories.csv')
data["class"] = data["class"].map({"B": 0, "S": 1})

# Replace '?' with NaN and drop rows with missing values
data.replace('?', pd.NA, inplace=True)
data.dropna(inplace=True)

# Define feature extraction functions
permissions_list = feature_df[feature_df["Category"] == "Manifest Permission"].X.unique()
api_call_signatures = feature_df[feature_df["Category"] == "API call signature"].X.unique()
intents = feature_df[feature_df["Category"] == "Intent"].X.unique()
keywords = feature_df[feature_df["Category"] == "Commands signature"].X.unique()

columns = ["filename"] + list(data.columns)

def analyze_apk(apk_file_path):
    a = APK(apk_file_path)
    d = DalvikVMFormat(a.get_dex())
    
    permissions = a.get_permissions()
    manifest = a.get_android_manifest_xml()
    intent_filters = manifest.findall(".//intent-filter")
    
    found_permissions = []
    found_api_signatures = []
    found_intents = []
    found_keywords = []

    with ThreadPoolExecutor(max_workers=4) as executor:
        futures = [
            executor.submit(extract_permissions, permissions, found_permissions),
            executor.submit(extract_api_calls, d, found_api_signatures),
            executor.submit(extract_intents, intent_filters, found_intents),
            executor.submit(extract_keywords, d, found_keywords),
        ]
        for future in futures:
            future.result()

    result = {"filename": apk_file_path}
    result.update({perm: 1 if perm in found_permissions else 0 for perm in permissions_list})
    result.update({api: 1 if api in found_api_signatures else 0 for api in api_call_signatures})
    result.update({intent: 1 if intent in found_intents else 0 for intent in intents})
    result.update({keyword: 1 if keyword in found_keywords else 0 for keyword in keywords})

    return result

def extract_permissions(permissions, found_permissions):
    for permission in permissions:
        permission = permission.split(".")[-1]
        if permission in permissions_list:
            found_permissions.append(permission)

def extract_api_calls(d, found_api_signatures):
    for method in d.get_methods():
        for api_call in api_call_signatures:
            if re.search(api_call, method.get_descriptor()):
                found_api_signatures.append(api_call)

def extract_intents(intent_filters, found_intents):
    for intent_filter in intent_filters:
        action_elements = intent_filter.findall(".//action")
        for action_element in action_elements:
            action_value = action_element.get("{http://schemas.android.com/apk/res/android}name")
            for intent in intents:
                if re.search(intent, action_value):
                    found_intents.append(intent)

def extract_keywords(d, found_keywords):
    for method in d.get_methods():
        for keyword in keywords:
            try:
                if re.search(keyword, method.get_code().get_instruction()):
                    found_keywords.append(keyword)
            except:
                pass

app = Flask(__name__)

async def is_malware(file_path):
    apk_file_path = file_path
    result = analyze_apk(apk_file_path)
    test_df = pd.DataFrame([result], columns=columns)
    dropped = test_df.drop(["filename", "class"], axis=1, errors='ignore')
    predictions = voting_clf.predict(dropped)
    dropped['prediction'] = predictions

    
    return predictions[0] == 1

@app.route('/analyze', methods=['POST'])
async def detect_apk():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400

    file_path = os.path.join("/tmp", file.filename)
    
    # Synchronously read the file and then asynchronously write it
    async with aiofiles.open(file_path, 'wb') as out_file:
        while content := file.read(1024):
            await out_file.write(content)

    if await is_malware(file_path):
        return jsonify({"result": "malware"}), 200
    else:
        return jsonify({"result": "clean"}), 200

if __name__ == '__main__':
    app.run(debug=False)